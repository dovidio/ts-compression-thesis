/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.dovidio.tsbenchmark;

import com.dovidio.tsbenchmark.compressor.*;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

    static HashMap<String, TimeSeries> timeSeriesHashMap;

    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("Usage: TsBenchmark gorilla/lz4/deflate/zstandard");
            System.exit(-1);
        }

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        // parse file
        timeSeriesHashMap = new HashMap<>();
        reader.lines().forEach(line -> {
            String[] parts = line.split(",");
            // ignore table name and time bucket
            String timeSeriesKey = String.join(",", Arrays.copyOfRange(parts, 1, parts.length - 3));
            long timestamp = Long.parseLong(parts[parts.length - 2]) / 1000;
            double value = Double.parseDouble(parts[parts.length - 1]);
            timeSeriesHashMap.computeIfAbsent(timeSeriesKey, TimeSeries::new).append(timestamp, value);
        });

        // compress
        String compressionType = args[0].toLowerCase();
        com.dovidio.tsbenchmark.compressor.Compressor compressor;
        switch (compressionType) {
            case "gorilla":
                compressor = new Gorilla();
                break;
            case "lz4":
                compressor = new LZ4();
                break;
            case "deflate":
                compressor = new Deflate();
                break;
            case "zstandard":
                compressor = new ZStandard();
                break;
            default:
                String errorMessage = String.format("Unknown compression method: %s. Allowed compression methods are Gorilla, LZ4, Deflate, ZStandard.\n", compressionType);
                throw new RuntimeException(errorMessage);
        }

        compress(compressor);
    }

    static void compress(Compressor compressor) {
        int initialSizeInBytes = 0;
        long compressedSizeInBytes = 0;
        HashMap<String, CompressedTimeSeries> compressedTimeSeries = new HashMap<>(timeSeriesHashMap.size());

        for (TimeSeries timeSeries : timeSeriesHashMap.values()) {
            byte[] compressedValues = compressor.compress(timeSeries);
            initialSizeInBytes += TimeSeries.toStream(timeSeries).length;
            compressedTimeSeries.put(timeSeries.name, new CompressedTimeSeries(initialSizeInBytes, compressedValues));
            compressedSizeInBytes += compressedValues.length;
        }

        for (Map.Entry<String, CompressedTimeSeries> t : compressedTimeSeries.entrySet()) {
            TimeSeries restored = compressor.restore(t.getKey(), t.getValue());
            if (!Objects.equals(timeSeriesHashMap.get(restored.name), restored)) {
                throw new RuntimeException(String.format("Could not restore compressed value of timeseries %s with compressor %s", restored.name, compressor.getClass().getSimpleName()));
            }
        }

        System.out.printf(Locale.US, "%d,%d,%e", initialSizeInBytes, compressedSizeInBytes, (initialSizeInBytes / (double) compressedSizeInBytes));
    }
}
