/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.dovidio.tsbenchmark;

import com.dovidio.tsbenchmark.compressor.*;
import com.github.luben.zstd.Zstd;
import com.google.common.collect.ImmutableList;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.zip.Deflater;
import java.util.zip.Inflater;

public class Main {

    static HashMap<String, TimeSeries> timeSeriesHashMap;

    static List<String> fileList = ImmutableList.of(
            "C:\\Users\\umber\\go\\src\\github.com\\timescale\\tsbs\\cmd\\tsbs_generate_data\\devops_1month_10hosts.txt"
            );

    public static void main(String[] args) throws Exception {
        if (args.length != 2) {
            System.out.println("Usage: TsBenchmark gorilla/lz4/deflate/zstandard srcFile dstFile");
            System.exit(-1);
        }

        Path path = Paths.get(fileList.get(0));
        if (!Files.exists(path)) {
            System.out.println("File not found");
            System.exit(-1);
        }

        // parse file
        timeSeriesHashMap = new HashMap<>();
        List<String> lines = Files.readAllLines(path);
        for (String line : lines) {
            String[] parts = line.split(",");
            // ignore table name and time bucket
            String timeSeriesKey = String.join(",", Arrays.copyOfRange(parts, 1, parts.length - 3));
            long timestamp = Long.parseLong(parts[parts.length - 2]) / 1000;
            double value = Double.parseDouble(parts[parts.length - 1]);
            timeSeriesHashMap.computeIfAbsent(timeSeriesKey, TimeSeries::new).append(timestamp, value);
        }

        // compress
        String compressionType = args[0].toLowerCase();
        com.dovidio.tsbenchmark.compressor.Compressor compressor;
        switch (compressionType) {
            case "gorilla":
                compressor = new Gorilla();
                break;
            case "lz4":
                compressor = new LZ4();
                break;
            case "deflate":
                compressor = new Deflate();
                break;
            case "zstandard":
                compressor = new ZStandard();
                break;
            default:
                String errorMessage = String.format("Unknown compression method: %s. Allowed compression methods are Gorilla, LZ4, Deflate, ZStandard.\n", compressionType);
                throw new RuntimeException(errorMessage);
        }

        compress(compressor);
    }

    static void compress(Compressor compressor) {
        int initialSizeInBytes = 0;
        long compressedSizeInBytes = 0;
        HashMap<String, CompressedTimeSeries> compressedTimeSeries = new HashMap<>(timeSeriesHashMap.size());

        for (TimeSeries timeSeries : timeSeriesHashMap.values()) {
            byte[] compressedValues = compressor.compress(timeSeries);
            initialSizeInBytes += TimeSeries.toStream(timeSeries).length;
            compressedTimeSeries.put(timeSeries.name, new CompressedTimeSeries(initialSizeInBytes, compressedValues));
            compressedSizeInBytes += compressedValues.length;

            System.out.println(compressedValues.length);
        }

        System.out.printf("Initial size: %d bytes. Compressed size: %d. Compression ratio: %f\n", initialSizeInBytes, compressedSizeInBytes, (initialSizeInBytes / (double) compressedSizeInBytes));

        for (Map.Entry<String, CompressedTimeSeries> t: compressedTimeSeries.entrySet()) {
            TimeSeries restored = compressor.restore(t.getKey(), t.getValue());
            if (!Objects.equals(timeSeriesHashMap.get(restored.name), restored)) {
                throw new RuntimeException(String.format("Could not restore compressed value of timeseries %s with compressor %s", restored.name, compressor.getClass().getSimpleName()));
            }
        }
    }

    static TimeSeries compressDeflate(TimeSeries timeSeries) throws Exception {
        System.out.println("====================== Starting deflate compression ======================");
        byte[] data = TimeSeries.toStream(timeSeries);
        System.out.println("====================== initial number of bytes: " + data.length + " ======================");
        byte[] output = new byte[data.length];

        // Compresses the data
        Deflater compresser = new Deflater();
        compresser.setInput(data);
        compresser.finish();
        int bytesAfterDeflate = compresser.deflate(output);
        System.out.println("====================== Compressed byte number: " + bytesAfterDeflate + " ======================");
        System.out.println("====================== Compression ratio: " + data.length / (double) bytesAfterDeflate + " ======================");

        // Decompresses the data
        Inflater decompresser = new Inflater();
        decompresser.setInput(output, 0, bytesAfterDeflate);
        byte[] result = new byte[data.length];
        int resultLength = decompresser.inflate(result);
        System.out.println("Compressed result length : " + resultLength);
        decompresser.end();

        return TimeSeries.toTimeSeries(result);
    }

    static TimeSeries compressZStandard(TimeSeries timeSeries) throws Exception {
        System.out.println("====================== Starting Zstandard compression ======================");
        byte[] data = TimeSeries.toStream(timeSeries);
        System.out.println("====================== initial number of bytes: " + data.length + " ======================");

        // Compresses the data
        Zstd zstd = new Zstd();
        byte[] bytesAfterZstd = zstd.compress(data);
        System.out.println("====================== Compressed byte number: " + bytesAfterZstd.length + " ======================");
        System.out.println("====================== Compression ratio: " + data.length / (double) bytesAfterZstd.length + " ======================");

        // Decompress the data
        byte[] result = new byte[data.length];
        zstd.decompress(result, bytesAfterZstd);

        return TimeSeries.toTimeSeries(result);
    }
}
