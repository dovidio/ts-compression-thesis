/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.dovidio.tsbenchmark;

import com.dovidio.tsbenchmark.compressor.*;
import com.dovidio.tsbenchmark.deserializer.Deserializer;
import com.dovidio.tsbenchmark.deserializer.DevOpsNamedDataPointExtractor;
import com.dovidio.tsbenchmark.deserializer.DynatraceNamedDataPointExtractor;
import com.dovidio.tsbenchmark.deserializer.TaxiNamedDataPointExtractor;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

@SuppressWarnings("unchecked")
public class Main {

    static Map<String, TimeSeries> timeSeriesHashMap;

    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println("Usage: TsBenchmark devops/dynatrace/taxi gorilla/lz4/deflate/zstandard");
            System.exit(-1);
        }

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        // parse file
        String inputFileType = args[0].toLowerCase();
        Deserializer deserializer;
        switch (inputFileType) {
            case "devops":
                deserializer = new Deserializer(new DevOpsNamedDataPointExtractor());
                break;
            case "dynatrace":
                deserializer = new Deserializer(new DynatraceNamedDataPointExtractor());
                break;
            case "taxi":
                deserializer = new Deserializer(new TaxiNamedDataPointExtractor());
                break;
            default:
                String errorMessage = String.format("Unknown input data type: %s. Allowed input data type are Devops, Dynatrace, Taxi.\n", inputFileType);
                throw new RuntimeException(errorMessage);
        }

        timeSeriesHashMap = deserializer.deserialize(reader);

        // compress
        String compressionType = args[1].toLowerCase();
        Compressor compressor;
        switch (compressionType) {
            case "gorilla":
                compressor = new Gorilla();
                break;
            case "lz4":
                compressor = new LZ4();
                break;
            case "deflate":
                compressor = new Deflate();
                break;
            case "zstandard":
                compressor = new ZStandard();
                break;
            case "pmc_mr":
                compressor = new PMC_MR_Compressor(parseError(args), parseInterval(args));
                break;
            default:
                String errorMessage = String.format("Unknown compression method: %s. Allowed compression methods are Gorilla, LZ4, Deflate, ZStandard.\n", compressionType);
                throw new RuntimeException(errorMessage);
        }

        compress(compressor);
    }

    private static long parseInterval(String[] args) {
        try {
            return Long.parseLong(args[3]);
        } catch (Exception e) {
            throw new RuntimeException("please specify an interval in milliseconds for PMC_MR compression");
        }
    }

    private static double parseError(String[] args) {
        try {
            return Double.parseDouble(args[2]);
        } catch (Exception e) {
            throw new RuntimeException("please specify an error bound for PMC_MR compression");
        }
    }

    static void compress(Compressor compressor) {
        int initialSizeInBytes = 0;
        int initialNumberOfDataPoints = 0;
        long compressedSizeInBytes = 0;
        // compress and keep track of byte size
        for (TimeSeries timeSeries : timeSeriesHashMap.values()) {
            int currentTimeSeriesByteSize = CompressionUtils.toByteArray(timeSeries).length;
            initialSizeInBytes += currentTimeSeriesByteSize;
            initialNumberOfDataPoints += timeSeries.dataPoints.size();
            List<Object> compressedValues = compressor.compress(timeSeries);
            CompressedTimeSeries compressedTimeSeries = new CompressedTimeSeries(currentTimeSeriesByteSize, compressedValues);
            compressedSizeInBytes += compressedTimeSeries.byteSize();

            if (compressor instanceof LosslessCompressor) {
                // lossless compression algorithms
                // let's verify we can restore the timeseries
                TimeSeries restored = ((LosslessCompressor) compressor).restore(timeSeries.name, compressedTimeSeries);
                if (!Objects.equals(timeSeries, restored)) {
                    throw new RuntimeException(String.format("Could not restore compressed value of timeseries %s with compressor %s", restored.name, compressor.getClass().getSimpleName()));
                }
            }

            // remove initial timeseries from memory, it's not needed anymore
            timeSeriesHashMap.put(timeSeries.name, null);
        }

        if (compressor instanceof LosslessCompressor) {
            // output initial size in byte, compressed size in byte and compression ratio
            System.out.printf(Locale.US, "%d,%d,%e", initialSizeInBytes, compressedSizeInBytes, (initialSizeInBytes / (double) compressedSizeInBytes));
        } else {
            // lossy compression algorithms
            // output number of initial data points and number of segments
            System.out.printf(Locale.US, "%d,%d,%e", initialNumberOfDataPoints, compressedSizeInBytes, (initialNumberOfDataPoints / (double) compressedSizeInBytes));
        }
    }
}
